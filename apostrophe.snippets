# Leading apostrophe snippets
priority 10
global !p
import re

# Checks if a string is a backslash. Used in snippets where you want to expand after a backslash
def isbackslash(string):
    if string == '\\':
	    return ''
    return string

def isMath():
    return int(vim.eval('vimtex#syntax#in_mathzone()')) > 0

def prose():
	return not isMath()

endglobal
##############################################

context "prose()"
snippet 'b "bold" iA
\\textbf{$1}
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\|\{\}\[\]\\]|^)'b' "bold" irA
`!p snip.rv = isbackslash(match.group(1))`\\mathbf{$1}
endsnippet


context "isMath()"
snippet 'c "cdot" A
\\cdot $0
endsnippet

context "isMath()"
snippet 'f "forall" A
\\forall $0
endsnippet

context "isMath()"
snippet 'h "hat" iA
\\hat{$1}
endsnippet

context "prose()"
snippet 'i "italic" iA
\\textit{$1}
endsnippet

context "isMath()"
snippet 'i "italic" iA
\\mathit{$1}
endsnippet

context "isMath()"
snippet 'l "leq" A
\\le $0
endsnippet

context "isMath()"
snippet 'o "overline" A
\\overline{$1}
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\|\{\}\[\]\\]|^)'p' "product in math mode" rA
`!p snip.rv = isbackslash(match.group(1))`\\prod
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\|\{\}\[\]\\]|^)'s' "sum in math mode" rA
`!p snip.rv = isbackslash(match.group(1))`\\sum
endsnippet

context "isMath()"
snippet 't "text in math mode" iA
\\text{$1}
endsnippet

context "isMath()"
snippet 'u "underline" iA
\\underline{$1}
endsnippet



# vim:ft=snippets:
